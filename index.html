<!DOCTYPE html>
<html lang="zh-CN" style="overflow: hidden;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¢å¼ºç‰ˆ HTML5 ä¿„ç½—æ–¯æ–¹å—</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- éŸ³æ•ˆæ–‡ä»¶ -->
    <audio id="moveSound" preload="auto" volume="0.3">
        <!-- ä½¿ç”¨Web Audio APIç”Ÿæˆçš„ç®€å•éŸ³æ•ˆ -->
    </audio>
    <audio id="dropSound" preload="auto" volume="0.4">
        <!-- ä¸‹è½éŸ³æ•ˆ -->
    </audio>
    <audio id="clearSound" preload="auto" volume="0.5">
        <!-- æ¶ˆè¡ŒéŸ³æ•ˆ -->
    </audio>
    <audio id="rotateSound" preload="auto" volume="0.2">
        <!-- æ—‹è½¬éŸ³æ•ˆ -->
    </audio>
    <style>
        :root {
            --bg-color: #0a0a0f;
            --panel-bg: rgba(255, 255, 255, 0.05);
            --border-color: rgba(255, 255, 255, 0.1);
            --text-color: #ffffff;
            --highlight-color: #58a6ff;
            --secondary-color: #7c3aed;
            --tertiary-color: #06b6d4;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --font-main: 'Roboto Mono', monospace;
            --font-title: 'Press Start 2P', cursive;
            --glass-bg: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.15);
            --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            --gradient-primary: linear-gradient(135deg, #58a6ff, #7c3aed);
            --gradient-secondary: linear-gradient(135deg, #06b6d4, #10b981);
        }

        body {
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0a0a0f 100%);
            color: var(--text-color);
            font-family: var(--font-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(88, 166, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(124, 58, 237, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(6, 182, 212, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
        
        h1 {
            font-family: var(--font-title);
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            text-shadow: 0 0 20px rgba(88, 166, 255, 0.5);
            margin-bottom: 30px;
            text-align: center;
            position: relative;
        }
        
        h1::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 3px;
            background: var(--gradient-primary);
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(88, 166, 255, 0.5);
        }

        .tetris-app {
            display: grid;
            grid-template-columns: minmax(180px, 1fr) auto minmax(180px, 1fr);
            gap: clamp(15px, 3vw, 25px);
            align-items: start;
            padding: clamp(15px, 3vw, 25px);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            box-shadow: var(--glass-shadow);
            position: relative;
            overflow: hidden;
            max-width: min(95vw, 1200px);
            margin: 0 auto;
        }
        
        @media (max-width: 768px) {
            .tetris-app {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                gap: clamp(10px, 2vw, 15px);
                padding: clamp(10px, 2vw, 20px);
            }
            
            .panel {
                order: 2;
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: clamp(8px, 2vw, 12px);
                width: 100%;
            }
            
            .game-area {
                order: 1;
                justify-self: center;
            }
            
            .right-panel {
                order: 3;
            }
        }
        
        .tetris-app::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: clamp(12px, 2.5vw, 18px);
            width: clamp(160px, 18vw, 200px);
            min-width: 160px;
        }
        
        @media (max-width: 1024px) {
            .panel {
                width: clamp(140px, 16vw, 180px);
                gap: clamp(10px, 2vw, 15px);
            }
        }

        .info-box {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            padding: clamp(10px, 2.5vw, 18px);
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            text-align: center;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            min-height: 70px;
        }
        
        @media (max-width: 768px) {
            .info-box {
                padding: clamp(8px, 2vw, 12px);
                border-radius: 10px;
                min-height: 50px;
            }
        }
        
        .info-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }
        
        .info-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border-color: rgba(88, 166, 255, 0.3);
        }

        .info-box h3 {
            margin: 0 0 clamp(8px, 2vw, 12px) 0;
            font-size: clamp(0.8rem, 1.8vw, 0.9rem);
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .info-box p {
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            margin: 0;
            font-weight: 700;
            color: var(--text-color);
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .game-area {
            position: relative;
            border: 2px solid var(--glass-border);
            border-radius: 15px;
            overflow: hidden;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 
                0 0 30px rgba(88, 166, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        
        @media (max-width: 768px) {
            .game-area {
                max-width: min(90vw, 350px);
                border-radius: 12px;
            }
        }
        
        .game-area:hover {
            border-color: rgba(88, 166, 255, 0.4);
            box-shadow: 
                0 0 40px rgba(88, 166, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(135deg, rgba(10, 10, 15, 0.9), rgba(22, 27, 34, 0.8));
            border-radius: 12px;
            width: 100%;
            height: auto;
            max-width: 360px;
        }
        
        @media (max-width: 768px) {
            #gameCanvas {
                max-width: min(85vw, 320px);
                border-radius: 10px;
            }
        }

        #holdCanvas {
            background: linear-gradient(135deg, rgba(10, 10, 15, 0.9), rgba(22, 27, 34, 0.8));
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            width: 100%;
            height: clamp(100px, 15vw, 120px);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        
        #holdCanvas:hover {
            border-color: rgba(88, 166, 255, 0.3);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.3),
                0 0 15px rgba(88, 166, 255, 0.1);
        }

        #next-previews {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .preview-canvas-small {
            width: 100%;
            height: clamp(50px, 8vw, 60px);
            background: linear-gradient(135deg, rgba(10, 10, 15, 0.9), rgba(22, 27, 34, 0.8));
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        
        .preview-canvas-small:hover {
            border-color: rgba(124, 58, 237, 0.3);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.3),
                0 0 15px rgba(124, 58, 237, 0.1);
        }
        
        .game-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            visibility: hidden;
            opacity: 0;
            transition: all 0.4s ease;
            border-radius: 12px;
            padding: clamp(15px, 3vw, 25px);
            box-sizing: border-box;
            overflow-y: auto;
        }
        
        @media (max-width: 768px) {
            .game-overlay {
                padding: clamp(10px, 2vw, 20px);
                border-radius: 10px;
            }
        }

        .game-overlay.visible {
            visibility: visible;
            opacity: 1;
        }
        
        .overlay-title {
            font-family: var(--font-title);
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: clamp(15px, 3vw, 25px);
            text-shadow: 0 0 20px rgba(88, 166, 255, 0.5);
            animation: pulse 2s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            from { text-shadow: 0 0 20px rgba(88, 166, 255, 0.5); }
            to { text-shadow: 0 0 30px rgba(88, 166, 255, 0.8); }
        }

        .overlay-text {
            font-size: clamp(1rem, 2.5vw, 1.4rem);
            margin-bottom: clamp(20px, 4vw, 35px);
            color: var(--text-color);
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            line-height: 1.6;
        }
        
        .overlay-button {
            font-family: var(--font-main);
            font-size: clamp(0.8rem, 1.8vw, 1rem);
            padding: clamp(8px, 2vw, 12px) clamp(16px, 3.5vw, 24px);
            margin: clamp(3px, 0.8vw, 6px);
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            color: var(--text-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 4px 15px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            width: 100%;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        @media (max-width: 768px) {
            .overlay-button {
                font-size: clamp(0.75rem, 1.6vw, 0.9rem);
                padding: clamp(6px, 1.8vw, 10px) clamp(12px, 3vw, 18px);
                margin: clamp(2px, 0.6vw, 4px);
                border-radius: 10px;
                min-height: 40px;
            }
        }
        
        .overlay-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .overlay-button:hover::before {
            left: 100%;
        }

        .overlay-button:hover {
            background: var(--gradient-primary);
            border-color: rgba(88, 166, 255, 0.6);
            color: white;
            transform: translateY(-2px);
            box-shadow: 
                0 8px 25px rgba(88, 166, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        .settings-content {
            width: 85%;
            max-height: 80%;
            overflow-y: auto;
            padding: clamp(15px, 3vw, 25px);
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid var(--glass-border);
        }

        .setting-item {
            margin-bottom: clamp(12px, 2.5vw, 18px);
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: clamp(8px, 1.5vw, 12px);
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }
        
        .setting-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(88, 166, 255, 0.2);
        }
        
        .setting-item.slider-item {
            flex-direction: column;
            align-items: flex-start;
        }

        .setting-item label {
            display: block;
            margin-bottom: 8px;
        }
        
        .setting-item input[type="range"] {
            width: 100%;
        }

        .keybind-button {
            width: 100px;
            padding: 5px;
            background-color: var(--border-color);
            color: var(--text-color);
            border: 1px solid var(--highlight-color);
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            font-family: var(--font-main);
        }
        .keybind-button:hover {
            background-color: var(--highlight-color);
            color: var(--panel-bg);
        }
        .keybind-button.is-binding {
            background-color: #f7b733;
            color: var(--bg-color);
        }

    </style>
</head>
<body>

    <h1>T E T R I S</h1>

    <div class="tetris-app">
        <!-- å·¦ä¾§é¢æ¿ -->
        <div class="panel left-panel">
            <div class="info-box">
                <h3>æš‚å­˜ (Hold)</h3>
                <canvas id="holdCanvas"></canvas>
            </div>
            <div class="info-box">
                <h3>åˆ†æ•° (Score)</h3>
                <p id="score">0</p>
            </div>
            <div class="info-box">
                <h3>ç­‰çº§ (Level)</h3>
                <p id="level">1</p>
            </div>
            <div class="info-box">
                <h3>è¡Œæ•° (Lines)</h3>
                <p id="lines">0</p>
            </div>
        </div>

        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            <!-- é®ç½©å±‚ -->
            <div id="startScreen" class="game-overlay visible">
                <div class="overlay-title">é€‰æ‹©æ¨¡å¼</div>
                <button class="overlay-button" onclick="startGame('CLASSIC')">ç»å…¸æ¨¡å¼</button>
                <button class="overlay-button" onclick="startGame('SPRINT')">40è¡Œå†²åˆº</button>
                <button class="overlay-button" onclick="showSettingsScreen()">è®¾ç½® (Settings)</button>
                <button class="overlay-button" onclick="showAboutScreen()">å…³äº (About)</button>
            </div>
            <div id="settingsScreen" class="game-overlay">
                <div class="overlay-title">è®¾ç½®</div>
                <div class="settings-content">
                    <div class="setting-item slider-item">
                        <label for="das-slider">æŒ‰é”®å»¶è¿Ÿ (DAS): <span id="das-value"></span>ms</label>
                        <input type="range" id="das-slider" min="80" max="300" step="10">
                    </div>
                    <div class="setting-item slider-item">
                        <label for="arr-slider">é‡å¤é€Ÿç‡ (ARR): <span id="arr-value"></span>ms</label>
                        <input type="range" id="arr-slider" min="10" max="100" step="5">
                    </div>
                    <div class="setting-item">
                         <label for="ghost-toggle">é¬¼å½±æ–¹å—</label>
                         <input type="checkbox" id="ghost-toggle">
                    </div>
                    <hr>
                    <h4>æŒ‰é”®è®¾ç½®</h4>
                    <div class="setting-item">
                        <label>å·¦ç§»</label> <button class="keybind-button" data-action="moveLeft"></button>
                    </div>
                    <div class="setting-item">
                        <label>å³ç§»</label> <button class="keybind-button" data-action="moveRight"></button>
                    </div>
                    <div class="setting-item">
                        <label>è½¯ä¸‹é™</label> <button class="keybind-button" data-action="softDrop"></button>
                    </div>
                    <div class="setting-item">
                        <label>ç¡¬ä¸‹é™</label> <button class="keybind-button" data-action="hardDrop"></button>
                    </div>
                    <div class="setting-item">
                        <label>é¡ºæ—¶é’ˆæ—‹è½¬</label> <button class="keybind-button" data-action="rotateCW"></button>
                    </div>
                    <div class="setting-item">
                        <label>é€†æ—¶é’ˆæ—‹è½¬</label> <button class="keybind-button" data-action="rotateCCW"></button>
                    </div>
                     <div class="setting-item">
                        <label>180Â°æ—‹è½¬</label> <button class="keybind-button" data-action="rotate180"></button>
                    </div>
                    <div class="setting-item">
                        <label>æš‚å­˜</label> <button class="keybind-button" data-action="hold"></button>
                    </div>
                     <div class="setting-item">
                        <label>æš‚åœ</label> <button class="keybind-button" data-action="pause"></button>
                    </div>
                </div>
                <div>
                    <button class="overlay-button" onclick="saveSettings()">ä¿å­˜å¹¶è¿”å›</button>
                </div>
            </div>
            <div id="pauseScreen" class="game-overlay">
                <div class="overlay-title">å·²æš‚åœ</div>
                <button class="overlay-button" onclick="togglePause()">ç»§ç»­æ¸¸æˆ</button>
            </div>
            <div id="gameOverScreen" class="game-overlay">
                <div class="overlay-title">æ¸¸æˆç»“æŸ</div>
                <div id="finalScoreText" class="overlay-text"></div>
                <button class="overlay-button" onclick="showStartScreen()">è¿”å›ä¸»èœå•</button>
            </div>
            <div id="quitConfirmOverlay" class="game-overlay">
                <div class="overlay-text">æŒ‰ä½ESCé€€å‡º...</div>
            </div>
            <div id="aboutScreen" class="game-overlay">
                <div class="overlay-title">å…³äºæ¸¸æˆ</div>
                <div class="settings-content" style="max-width: min(90vw, 600px); margin: 0 auto;">
                    <div style="text-align: center; padding: clamp(15px, 3vw, 25px);">
                        <h3 style="color: var(--highlight-color); margin-bottom: clamp(15px, 3vw, 25px); font-size: clamp(1.2rem, 3vw, 1.8rem); font-weight: 600;">å¢å¼ºç‰ˆ HTML5 ä¿„ç½—æ–¯æ–¹å—</h3>
                        
                        <div class="about-card" style="background: var(--glass-bg); border-radius: 16px; padding: clamp(15px, 3vw, 25px); margin: clamp(15px, 3vw, 20px) 0; border: 1px solid var(--glass-border); backdrop-filter: blur(10px); transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 10px 30px rgba(88, 166, 255, 0.2)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                            <h4 style="color: var(--secondary-color); margin-bottom: clamp(12px, 2.5vw, 18px); font-size: clamp(1rem, 2.2vw, 1.3rem); display: flex; align-items: center; justify-content: center; gap: 8px;">ğŸ‘¨â€ğŸ’» å¼€å‘è€…ä¿¡æ¯</h4>
                            <div style="display: grid; gap: clamp(8px, 1.5vw, 12px); text-align: left;">
                                <p style="margin: 0; font-size: clamp(0.95rem, 2vw, 1.1rem); display: flex; align-items: center; gap: 10px;"><span style="color: var(--highlight-color); font-weight: 600;">ğŸ‘¤ ä½œè€…:</span> èƒ¡æ–‡å‡¯</p>
                                <p style="margin: 0; font-size: clamp(0.95rem, 2vw, 1.1rem); display: flex; align-items: center; gap: 10px;"><span style="color: var(--highlight-color); font-weight: 600;">ğŸ“§ é‚®ç®±:</span> wenkai5@foxmail.com</p>
                            </div>
                        </div>
                        
                        <div class="about-card" style="background: var(--glass-bg); border-radius: 16px; padding: clamp(15px, 3vw, 25px); margin: clamp(15px, 3vw, 20px) 0; border: 1px solid var(--glass-border); backdrop-filter: blur(10px); transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 10px 30px rgba(6, 182, 212, 0.2)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                            <h4 style="color: var(--tertiary-color); margin-bottom: clamp(12px, 2.5vw, 18px); font-size: clamp(1rem, 2.2vw, 1.3rem); display: flex; align-items: center; justify-content: center; gap: 8px;">âœ¨ æ¸¸æˆç‰¹è‰²</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(min(250px, 100%), 1fr)); gap: clamp(8px, 1.5vw, 12px); text-align: left;">
                                <div style="display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; background: rgba(255, 255, 255, 0.03);"><span style="font-size: 1.2em;">ğŸ®</span><span style="font-size: clamp(0.85rem, 1.8vw, 1rem);">ç°ä»£æ¶²æ€ç»ç’ƒUIè®¾è®¡</span></div>
                                <div style="display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; background: rgba(255, 255, 255, 0.03);"><span style="font-size: 1.2em;">âš¡</span><span style="font-size: clamp(0.85rem, 1.8vw, 1rem);">é«˜æ€§èƒ½Canvasæ¸²æŸ“</span></div>
                                <div style="display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; background: rgba(255, 255, 255, 0.03);"><span style="font-size: 1.2em;">ğŸ¯</span><span style="font-size: clamp(0.85rem, 1.8vw, 1rem);">æ™ºèƒ½AIå¯¹æˆ˜æ¨¡å¼</span></div>
                                <div style="display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; background: rgba(255, 255, 255, 0.03);"><span style="font-size: 1.2em;">ğŸƒ</span><span style="font-size: clamp(0.85rem, 1.8vw, 1rem);">40è¡Œå†²åˆºæŒ‘æˆ˜</span></div>
                                <div style="display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; background: rgba(255, 255, 255, 0.03);"><span style="font-size: 1.2em;">âŒ¨ï¸</span><span style="font-size: clamp(0.85rem, 1.8vw, 1rem);">è‡ªå®šä¹‰æŒ‰é”®ç»‘å®š</span></div>
                                <div style="display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; background: rgba(255, 255, 255, 0.03);"><span style="font-size: 1.2em;">ğŸ‘»</span><span style="font-size: clamp(0.85rem, 1.8vw, 1rem);">é¬¼å½±æ–¹å—é¢„è§ˆ</span></div>
                            </div>
                        </div>
                        
                        <div class="about-card" style="background: var(--glass-bg); border-radius: 16px; padding: clamp(15px, 3vw, 25px); margin: clamp(15px, 3vw, 20px) 0; border: 1px solid var(--glass-border); backdrop-filter: blur(10px); transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 10px 30px rgba(16, 185, 129, 0.2)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                            <h4 style="color: var(--success-color); margin-bottom: clamp(12px, 2.5vw, 18px); font-size: clamp(1rem, 2.2vw, 1.3rem); display: flex; align-items: center; justify-content: center; gap: 8px;">ğŸ› ï¸ æŠ€æœ¯æ ˆ</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: clamp(8px, 1.5vw, 12px); justify-content: center;">
                                <span style="background: rgba(88, 166, 255, 0.2); color: var(--highlight-color); padding: 6px 12px; border-radius: 20px; font-size: clamp(0.8rem, 1.6vw, 0.95rem); font-weight: 500;">HTML5 Canvas</span>
                                <span style="background: rgba(245, 158, 11, 0.2); color: #f59e0b; padding: 6px 12px; border-radius: 20px; font-size: clamp(0.8rem, 1.6vw, 0.95rem); font-weight: 500;">JavaScript ES6+</span>
                                <span style="background: rgba(124, 58, 237, 0.2); color: var(--secondary-color); padding: 6px 12px; border-radius: 20px; font-size: clamp(0.8rem, 1.6vw, 0.95rem); font-weight: 500;">CSS3</span>
                                <span style="background: rgba(6, 182, 212, 0.2); color: var(--tertiary-color); padding: 6px 12px; border-radius: 20px; font-size: clamp(0.8rem, 1.6vw, 0.95rem); font-weight: 500;">å“åº”å¼è®¾è®¡</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="margin-top: clamp(15px, 3vw, 25px);">
                    <button class="overlay-button" onclick="showStartScreen()">è¿”å›ä¸»èœå•</button>
                </div>
            </div>
        </div>

        <!-- å³ä¾§é¢æ¿ -->
        <div class="panel right-panel">
            <div class="info-box">
                <h3>ä¸‹ä¸€ä¸ª (Next)</h3>
                <div id="next-previews">
                    <canvas id="next-1" class="preview-canvas-small"></canvas>
                    <canvas id="next-2" class="preview-canvas-small"></canvas>
                    <canvas id="next-3" class="preview-canvas-small"></canvas>
                    <canvas id="next-4" class="preview-canvas-small"></canvas>
                    <canvas id="next-5" class="preview-canvas-small"></canvas>
                </div>
            </div>
            <div class="info-box">
                <h3>æœ€é«˜åˆ†</h3>
                <p id="highScore">0</p>
            </div>
            <div id="sprintTimerBox" class="info-box" style="display: none;">
                <h3>è®¡æ—¶å™¨</h3>
                <p id="sprintTimer">0.00</p>
            </div>
        </div>
    </div>

    <script>
    // 1. åˆå§‹åŒ–å’Œå¸¸é‡
    // ===================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const holdCanvas = document.getElementById('holdCanvas');
    const holdCtx = holdCanvas.getContext('2d');
    const nextPreviewContexts = [
        document.getElementById('next-1').getContext('2d'),
        document.getElementById('next-2').getContext('2d'),
        document.getElementById('next-3').getContext('2d'),
        document.getElementById('next-4').getContext('2d'),
        document.getElementById('next-5').getContext('2d'),
    ];

    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const linesEl = document.getElementById('lines');
    const highScoreEl = document.getElementById('highScore');
    const sprintTimerEl = document.getElementById('sprintTimer');
    const sprintTimerBox = document.getElementById('sprintTimerBox');
    
    const startScreen = document.getElementById('startScreen');
    const settingsScreen = document.getElementById('settingsScreen');
    const pauseScreen = document.getElementById('pauseScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreText = document.getElementById('finalScoreText');
    const quitConfirmOverlay = document.getElementById('quitConfirmOverlay');

    const dasSlider = document.getElementById('das-slider');
    const dasValue = document.getElementById('das-value');
    const arrSlider = document.getElementById('arr-slider');
    const arrValue = document.getElementById('arr-value');
    const ghostToggle = document.getElementById('ghost-toggle');

    const ROWS = 20;
    const COLS = 10;
    let BLOCK_SIZE = 30;
    
    // è‡ªé€‚åº”çª—å£å¤§å°è®¡ç®—
    function calculateOptimalSize() {
        const gameArea = document.querySelector('.game-area');
        const maxWidth = Math.min(window.innerWidth * 0.4, 400);
        const maxHeight = Math.min(window.innerHeight * 0.8, 600);
        
        const blockSizeByWidth = Math.floor(maxWidth / COLS);
        const blockSizeByHeight = Math.floor(maxHeight / ROWS);
        
        BLOCK_SIZE = Math.min(blockSizeByWidth, blockSizeByHeight, 35);
        BLOCK_SIZE = Math.max(BLOCK_SIZE, 15); // æœ€å°å°ºå¯¸
        
        return {
            width: COLS * BLOCK_SIZE,
            height: ROWS * BLOCK_SIZE
        };
    }
    const GHOST_ALPHA = 0.3;
    const QUIT_HOLD_DURATION = 1000;

    let settings = {
        das: 160,
        arr: 40,
        showGhost: true,
        keybindings: {
            moveLeft: 'a',
            moveRight: 'd',
            softDrop: 's',
            hardDrop: 'w',
            rotateCW: 'arrowright',
            rotateCCW: 'arrowleft',
            rotate180: 'arrowup',
            hold: 'arrowdown',
            pause: 'p'
        }
    };

    // åˆå§‹åŒ–canvaså°ºå¯¸
    function initializeCanvas() {
        const size = calculateOptimalSize();
        canvas.width = size.width;
        canvas.height = size.height;
        canvas.style.width = size.width + 'px';
        canvas.style.height = size.height + 'px';
    }
    
    initializeCanvas();
    
    // çª—å£å¤§å°å˜åŒ–ç›‘å¬
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            initializeCanvas();
            if (gameState === 'PLAYING' || gameState === 'PAUSED') {
                draw();
            }
        }, 100);
    });
    
    function initializePreviewCanvases() {
        [holdCtx, ...nextPreviewContexts].forEach(c => {
            const canvasEl = c.canvas;
            const rect = canvasEl.getBoundingClientRect();
            canvasEl.width = rect.width;
            canvasEl.height = rect.height;
        });
    }
    
    initializePreviewCanvases();
    
    // åœ¨çª—å£å¤§å°å˜åŒ–æ—¶ä¹Ÿæ›´æ–°é¢„è§ˆcanvas
    const originalResizeHandler = window.onresize;
    window.addEventListener('resize', () => {
        setTimeout(initializePreviewCanvases, 150);
    });

    const computedStyles = getComputedStyle(document.documentElement);
    const BG_COLOR = computedStyles.getPropertyValue('--bg-color').trim();

    const COLORS = [
        null, 
        'linear-gradient(135deg, rgba(230, 0, 103, 0.9), rgba(230, 0, 103, 0.7))', // T - ç²‰çº¢è‰²ç»ç’ƒ
        'linear-gradient(135deg, rgba(0, 230, 230, 0.9), rgba(0, 230, 230, 0.7))', // I - é’è‰²ç»ç’ƒ
        'linear-gradient(135deg, rgba(230, 230, 0, 0.9), rgba(230, 230, 0, 0.7))', // O - é»„è‰²ç»ç’ƒ
        'linear-gradient(135deg, rgba(88, 166, 255, 0.9), rgba(88, 166, 255, 0.7))', // L - è“è‰²ç»ç’ƒ
        'linear-gradient(135deg, rgba(124, 58, 237, 0.9), rgba(124, 58, 237, 0.7))', // J - ç´«è‰²ç»ç’ƒ
        'linear-gradient(135deg, rgba(16, 185, 129, 0.9), rgba(16, 185, 129, 0.7))', // S - ç»¿è‰²ç»ç’ƒ
        'linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(239, 68, 68, 0.7))', // Z - çº¢è‰²ç»ç’ƒ
        'linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7))' // ç™½è‰²ç»ç’ƒ
    ];
    
    const GLASS_EFFECTS = [
        null,
        'rgba(230, 0, 103, 0.3)', // T
        'rgba(0, 230, 230, 0.3)', // I
        'rgba(230, 230, 0, 0.3)', // O
        'rgba(88, 166, 255, 0.3)', // L
        'rgba(124, 58, 237, 0.3)', // J
        'rgba(16, 185, 129, 0.3)', // S
        'rgba(239, 68, 68, 0.3)', // Z
        'rgba(255, 255, 255, 0.3)' // ç™½è‰²
    ];

    const TETROMINOS = [
        [], // Empty
        [[0, 1, 0], [1, 1, 1]], // T
        [[2, 2, 2, 2]],         // I
        [[3, 3], [3, 3]],       // O
        [[0, 0, 4], [4, 4, 4]], // L
        [[5, 0, 0], [5, 5, 5]], // J
        [[0, 6, 6], [6, 6, 0]], // S
        [[7, 7, 0], [0, 7, 7]]  // Z
    ];

    let gameState = 'MENU';
    let gameMode = 'CLASSIC';

    let grid, piece, holdPiece, bag, nextPieces;
    let score, level, lines, highScore;
    let canHold, isAnimating;
    
    const keysPressed = {};
    const moveState = {
        left: { timer: 0, arrTimer: 0 },
        right: { timer: 0, arrTimer: 0 },
        down: { timer: 0, arrTimer: 0 }
    };
    
    let sprintStartTime, sprintIntervalId;
    let lastTime = 0, dropCounter = 0, dropInterval = 1000;
    let isRebinding = false;
    let quitConfirmTimer = null;

    // éŸ³æ•ˆç³»ç»Ÿ
    let audioContext;
    let soundEnabled = true;
    
    // åˆå§‹åŒ–éŸ³æ•ˆç³»ç»Ÿ
    function initAudioSystem() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn('Web Audio API not supported');
            soundEnabled = false;
        }
    }
    
    // ç”ŸæˆéŸ³æ•ˆ
    function playSound(type) {
        if (!soundEnabled || !audioContext) return;
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        let frequency, duration, volume;
        
        switch(type) {
            case 'move':
                frequency = 220; // A3
                duration = 0.1;
                volume = 0.1;
                break;
            case 'rotate':
                frequency = 330; // E4
                duration = 0.08;
                volume = 0.08;
                break;
            case 'drop':
                frequency = 110; // A2
                duration = 0.15;
                volume = 0.15;
                break;
            case 'clear':
                frequency = 440; // A4
                duration = 0.3;
                volume = 0.2;
                break;
            default:
                return;
        }
        
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        oscillator.type = type === 'clear' ? 'square' : 'sine';
        
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }
    
    // ä¸ºæ¶ˆè¡Œæ·»åŠ ç‰¹æ®ŠéŸ³æ•ˆ
    function playClearSound(lineCount) {
        if (!soundEnabled || !audioContext) return;
        
        const frequencies = [440, 554, 659, 880]; // A4, C#5, E5, A5
        const baseTime = audioContext.currentTime;
        
        for (let i = 0; i < lineCount; i++) {
            setTimeout(() => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequencies[i] || 880, audioContext.currentTime);
                oscillator.type = 'square';
                
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            }, i * 50);
        }
    }


    // 2. æ¸¸æˆæ ¸å¿ƒç±»å’Œå‡½æ•°
    // ===================================
    class Piece {
        constructor(shape, context) {
            this.shape = shape;
            this.color = COLORS[shape.flat().find(val => val > 0)];
            this.ctx = context;
            this.x = Math.floor(COLS / 2) - Math.floor(this.shape[0].length / 2);
            this.y = 0;
        }

        draw(isGhost = false) {
            if (isGhost && !settings.showGhost) return;
            
            this.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        const blockX = (this.x + x) * BLOCK_SIZE;
                        const blockY = (this.y + y) * BLOCK_SIZE;
                        
                        this.ctx.save();
                        
                        if (isGhost) {
                            this.ctx.globalAlpha = GHOST_ALPHA;
                        }
                        
                        // åˆ›å»ºæ¶²æ€ç»ç’ƒæ•ˆæœçš„æ¸å˜
                        const gradient = this.ctx.createLinearGradient(
                            blockX, blockY, 
                            blockX + BLOCK_SIZE, blockY + BLOCK_SIZE
                        );
                        
                        // è§£ææ¸å˜é¢œè‰²
                        const colorMatch = this.color.match(/rgba\([^)]+\)/g);
                        if (colorMatch && colorMatch.length >= 2) {
                            gradient.addColorStop(0, colorMatch[0]);
                            gradient.addColorStop(1, colorMatch[1]);
                        } else {
                            // å¤‡ç”¨é¢œè‰²
                            gradient.addColorStop(0, 'rgba(88, 166, 255, 0.9)');
                            gradient.addColorStop(1, 'rgba(88, 166, 255, 0.7)');
                        }
                        
                        // ç»˜åˆ¶ä¸»ä½“
                        this.ctx.fillStyle = gradient;
                        this.ctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
                        
                        // æ·»åŠ ç»ç’ƒé«˜å…‰æ•ˆæœ
                        const highlightGradient = this.ctx.createLinearGradient(
                            blockX, blockY, 
                            blockX + BLOCK_SIZE * 0.6, blockY + BLOCK_SIZE * 0.6
                        );
                        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        this.ctx.fillStyle = highlightGradient;
                        this.ctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
                        
                        // æ·»åŠ è¾¹æ¡†
                        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(blockX + 0.5, blockY + 0.5, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        
                        this.ctx.restore();
                    }
                });
            });
        }
    }

    function generateBag() {
        const pieces = [1, 2, 3, 4, 5, 6, 7];
        for (let i = pieces.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
        }
        bag.push(...pieces);
    }

    function getNextFromBag() {
        if (bag.length < 7) generateBag();
        return new Piece(TETROMINOS[bag.shift()], ctx);
    }

    function rotate(p, dir) {
        let tempShape;
        if (dir === 1) { // Clockwise
            tempShape = p.shape[0].map((_, colIndex) => p.shape.map(row => row[colIndex]).reverse());
        } else if (dir === -1) { // Counter-clockwise
            tempShape = p.shape[0].map((_, colIndex) => p.shape.map(row => row[colIndex])).reverse();
        } else if (dir === 2) { // 180 degrees
            tempShape = p.shape.map(row => [...row].reverse()).reverse();
        } else {
            return;
        }

        const originalShape = p.shape;
        const originalX = p.x;
        p.shape = tempShape;

        let offset = 0;
        while (checkCollision(p, grid)) {
            offset = (offset >= 0) ? -(offset + 1) : -offset;
            p.x += offset;
            if (Math.abs(offset) > p.shape[0].length + 1) {
                p.shape = originalShape;
                p.x = originalX;
                return;
            }
        }
        playSound('rotate');
    }
    
    function checkCollision(p, g) {
        return p.shape.some((row, dy) => 
            row.some((value, dx) => {
                if (value === 0) return false;
                const newX = p.x + dx;
                const newY = p.y + dy;
                return newX < 0 || newX >= COLS || newY >= ROWS || (g[newY] && g[newY][newX] !== 0);
            })
        );
    }

    function lockPiece() {
        piece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value > 0 && piece.y + y >= 0) {
                   grid[piece.y + y][piece.x + x] = value;
                }
            });
        });
    }

    function clearLines() {
        const newGrid = grid.filter(row => row.some(cell => cell === 0));
        const clearedCount = ROWS - newGrid.length;

        if (clearedCount > 0) {
            isAnimating = true;
            playClearSound(clearedCount);
            let flashCount = 0;
            const flashInterval = setInterval(() => {
                flashCount++;
                if (flashCount >= 4) {
                    clearInterval(flashInterval);
                    isAnimating = false;
                    for (let i = 0; i < clearedCount; i++) {
                        newGrid.unshift(Array(COLS).fill(0));
                    }
                    grid = newGrid;
                    updateScore(clearedCount);
                    spawnNewPiece();
                }
            }, 60);
        } else {
            spawnNewPiece();
        }
    }
    
    function spawnNewPiece() {
        piece = nextPieces.shift();
        piece.ctx = ctx;
        nextPieces.push(getNextFromBag());
        canHold = true;
        if (checkCollision(piece, grid)) {
            gameOver();
        }
    }
    
    function updateScore(clearedCount) {
        const linePoints = [0, 100, 300, 500, 800];
        score += linePoints[clearedCount] * level;
        lines += clearedCount;
        
        if (gameMode === 'CLASSIC') {
            level = Math.floor(lines / 10) + 1;
            // å¢å¼ºç‰ˆç­‰çº§ä¸‹è½é€Ÿåº¦ï¼šæ›´å¿«çš„é€Ÿåº¦é€’å¢
            // 1çº§: 1000ms, 2çº§: 850ms, 3çº§: 700ms, 4çº§: 550ms, 5çº§: 400ms
            // 6çº§: 300ms, 7çº§: 200ms, 8çº§: 150ms, 9çº§: 100ms, 10çº§+: 50ms
            if (level <= 5) {
                dropInterval = Math.max(400, 1000 - (level - 1) * 150);
            } else if (level <= 8) {
                dropInterval = Math.max(100, 400 - (level - 5) * 100);
            } else if (level === 9) {
                dropInterval = 100;
            } else {
                dropInterval = 50; // 10çº§åŠä»¥ä¸Šä¿æŒæœ€é«˜é€Ÿåº¦
            }
        } else if (gameMode === 'SPRINT' && lines >= 40) {
            gameOver();
        }
        updateUI();
    }
    
    function handleHold() {
        if (!canHold) return;

        if (holdPiece) {
            [piece, holdPiece] = [new Piece(holdPiece.shape, ctx), new Piece(piece.shape, holdCtx)];
            piece.x = Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2);
            piece.y = 0;
            if (checkCollision(piece, grid)) {
                gameOver();
            }
        } else {
            holdPiece = new Piece(piece.shape, holdCtx);
            spawnNewPiece();
        }
        canHold = false;
        drawHoldPiece();
    }

    // 3. Game State & Main Loop
    // ===================================
    function startGame(mode) {
        // åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’ï¼‰
        if (!audioContext) {
            initAudioSystem();
        }
        
        // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœè¢«æš‚åœï¼‰
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        gameMode = mode;
        gameState = 'PLAYING';
        
        grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        bag = [];
        nextPieces = [];
        for (let i = 0; i < 5; i++) {
            nextPieces.push(getNextFromBag());
        }
        spawnNewPiece();

        holdPiece = null;
        canHold = true;
        isAnimating = false;

        score = 0; lines = 0; level = 1;
        dropInterval = 1000;
        
        Object.keys(keysPressed).forEach(key => keysPressed[key] = false);
        Object.keys(moveState).forEach(dir => {
            moveState[dir].timer = 0;
            moveState[dir].arrTimer = 0;
        });

        [startScreen, pauseScreen, gameOverScreen, settingsScreen, quitConfirmOverlay].forEach(s => s.classList.remove('visible'));
        
        if (gameMode === 'SPRINT') {
            sprintTimerBox.style.display = 'block';
            sprintStartTime = Date.now();
            sprintIntervalId = setInterval(() => {
                if (gameState === 'PLAYING') {
                    const elapsed = (Date.now() - sprintStartTime) / 1000;
                    sprintTimerEl.textContent = elapsed.toFixed(2);
                }
            }, 50);
        } else {
            sprintTimerBox.style.display = 'none';
        }

        loadHighScore();
        updateUI();
        drawHoldPiece();
        
        lastTime = 0;
        gameLoop();
    }
    
    function showStartScreen() {
        startScreen.classList.add('visible');
        gameOverScreen.classList.remove('visible');
        settingsScreen.classList.remove('visible');
        gameState = 'MENU';
    }

    function togglePause() {
        if (gameState !== 'PLAYING' && gameState !== 'PAUSED') return;
        gameState = (gameState === 'PAUSED') ? 'PLAYING' : 'PAUSED';
        pauseScreen.classList.toggle('visible', gameState === 'PAUSED');
        if (gameState === 'PLAYING') gameLoop();
    }

    function gameOver() {
        gameState = 'GAMEOVER';
        saveHighScore();
        
        if (gameMode === 'SPRINT') {
            clearInterval(sprintIntervalId);
            finalScoreText.innerHTML = (lines >= 40)
                ? `40è¡Œå®Œæˆ!<br>æ—¶é—´: ${sprintTimerEl.textContent}`
                : `æ¸¸æˆç»“æŸ<br>è¡Œæ•°: ${lines} / 40`;
        } else {
            finalScoreText.innerHTML = `æœ€ç»ˆå¾—åˆ†: ${score}`;
        }
        
        gameOverScreen.classList.add('visible');
    }

    function handleMovement(deltaTime) {
        if (isAnimating || gameState !== 'PLAYING') return;

        if (keysPressed[settings.keybindings.moveLeft]) moveState.left.timer += deltaTime;
        if (keysPressed[settings.keybindings.moveRight]) moveState.right.timer += deltaTime;
        if (keysPressed[settings.keybindings.softDrop]) moveState.down.timer += deltaTime;

        if (moveState.left.timer > settings.das) {
            moveState.left.arrTimer += deltaTime;
            if (moveState.left.arrTimer > settings.arr) {
                const oldX = piece.x;
                piece.x--;
                if (checkCollision(piece, grid)) {
                    piece.x++;
                } else if (oldX !== piece.x) {
                    playSound('move');
                }
                moveState.left.arrTimer = 0;
            }
        }
        if (moveState.right.timer > settings.das) {
            moveState.right.arrTimer += deltaTime;
            if (moveState.right.arrTimer > settings.arr) {
                const oldX = piece.x;
                piece.x++;
                if (checkCollision(piece, grid)) {
                    piece.x--;
                } else if (oldX !== piece.x) {
                    playSound('move');
                }
                moveState.right.arrTimer = 0;
            }
        }
        if (moveState.down.timer > 0) {
             moveState.down.arrTimer += deltaTime;
             if(moveState.down.arrTimer > settings.arr / 2){
                const oldY = piece.y;
                piece.y++;
                if (checkCollision(piece, grid)) {
                    piece.y--;
                } else {
                    if (gameMode === 'CLASSIC') score += 1;
                    dropCounter = 0;
                    if (oldY !== piece.y) {
                        playSound('move');
                    }
                }
                moveState.down.arrTimer = 0;
             }
        }
    }

    function gameLoop(time = 0) {
        if (gameState !== 'PLAYING') return;

        const deltaTime = time - lastTime;
        lastTime = time;

        handleMovement(deltaTime);

        if (!isAnimating) {
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                piece.y++;
                if (checkCollision(piece, grid)) {
                    piece.y--;
                    playSound('drop');
                    lockPiece();
                    clearLines();
                }
                dropCounter = 0;
            }
        }

        draw();
        requestAnimationFrame(gameLoop);
    }

    // 4. Drawing & UI
    // ===================================
    function draw() {
        ctx.fillStyle = BG_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        grid.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value > 0) {
                    const blockX = x * BLOCK_SIZE;
                    const blockY = y * BLOCK_SIZE;
                    
                    // åˆ›å»ºæ¶²æ€ç»ç’ƒæ•ˆæœçš„æ¸å˜
                    const gradient = ctx.createLinearGradient(
                        blockX, blockY, 
                        blockX + BLOCK_SIZE, blockY + BLOCK_SIZE
                    );
                    
                    // è§£ææ¸å˜é¢œè‰²
                    const color = COLORS[value];
                    const colorMatch = color.match(/rgba\([^)]+\)/g);
                    if (colorMatch && colorMatch.length >= 2) {
                        gradient.addColorStop(0, colorMatch[0]);
                        gradient.addColorStop(1, colorMatch[1]);
                    } else {
                        // å¤‡ç”¨é¢œè‰²
                        gradient.addColorStop(0, 'rgba(88, 166, 255, 0.9)');
                        gradient.addColorStop(1, 'rgba(88, 166, 255, 0.7)');
                    }
                    
                    // ç»˜åˆ¶ä¸»ä½“
                    ctx.fillStyle = gradient;
                    ctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
                    
                    // æ·»åŠ ç»ç’ƒé«˜å…‰æ•ˆæœ
                    const highlightGradient = ctx.createLinearGradient(
                        blockX, blockY, 
                        blockX + BLOCK_SIZE * 0.6, blockY + BLOCK_SIZE * 0.6
                    );
                    highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                    highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.fillStyle = highlightGradient;
                    ctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
                    
                    // æ·»åŠ è¾¹æ¡†
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(blockX + 0.5, blockY + 0.5, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                }
            });
        });
        
        if (gameState === 'PLAYING' && !isAnimating) {
            const ghost = new Piece(piece.shape, ctx);
            ghost.x = piece.x; ghost.y = piece.y;
            while (!checkCollision(ghost, grid)) ghost.y++;
            ghost.y--;
            ghost.draw(true);
            piece.draw();
        }
        
        drawNextPieces();
    }
    
    function drawPreview(p, context) {
        const canvasEl = context.canvas;
        context.fillStyle = BG_COLOR;
        context.fillRect(0, 0, canvasEl.width, canvasEl.height);
        if (!p) return;
        
        const shape = p.shape;
        const blockSize = Math.min(canvasEl.width / 6, canvasEl.height / 6);
        const shapeWidth = shape[0].length * blockSize;
        const shapeHeight = shape.length * blockSize;
        const startX = (canvasEl.width - shapeWidth) / 2;
        const startY = (canvasEl.height - shapeHeight) / 2;
        
        shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value > 0) {
                    const blockX = startX + x * blockSize;
                    const blockY = startY + y * blockSize;
                    
                    // åˆ›å»ºæ¶²æ€ç»ç’ƒæ•ˆæœçš„æ¸å˜
                    const gradient = context.createLinearGradient(
                        blockX, blockY, 
                        blockX + blockSize, blockY + blockSize
                    );
                    
                    // è§£ææ¸å˜é¢œè‰²
                    const color = COLORS[value];
                    const colorMatch = color.match(/rgba\([^)]+\)/g);
                    if (colorMatch && colorMatch.length >= 2) {
                        gradient.addColorStop(0, colorMatch[0]);
                        gradient.addColorStop(1, colorMatch[1]);
                    } else {
                        gradient.addColorStop(0, 'rgba(88, 166, 255, 0.9)');
                        gradient.addColorStop(1, 'rgba(88, 166, 255, 0.7)');
                    }
                    
                    // ç»˜åˆ¶ä¸»ä½“
                    context.fillStyle = gradient;
                    context.fillRect(blockX, blockY, blockSize, blockSize);
                    
                    // æ·»åŠ ç»ç’ƒé«˜å…‰æ•ˆæœ
                    const highlightGradient = context.createLinearGradient(
                        blockX, blockY, 
                        blockX + blockSize * 0.6, blockY + blockSize * 0.6
                    );
                    highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                    highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    context.fillStyle = highlightGradient;
                    context.fillRect(blockX, blockY, blockSize, blockSize);
                    
                    // æ·»åŠ è¾¹æ¡†
                    context.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    context.lineWidth = 1;
                    context.strokeRect(blockX + 0.5, blockY + 0.5, blockSize - 1, blockSize - 1);
                }
            });
        });
    }

    const drawNextPieces = () => nextPieces.forEach((p, i) => drawPreview(p, nextPreviewContexts[i]));
    const drawHoldPiece = () => drawPreview(holdPiece, holdCtx);

    function updateUI() {
        scoreEl.textContent = score;
        levelEl.textContent = level;
        linesEl.textContent = (gameMode === 'SPRINT') ? `${lines} / 40` : lines;
        highScoreEl.textContent = highScore;
    }

    function loadHighScore() {
        highScore = parseInt(localStorage.getItem('tetrisHighScore_v4') || 0, 10);
    }
    
    function saveHighScore() {
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('tetrisHighScore_v4', highScore);
            updateUI(); // FIX: Update UI immediately when a new high score is set.
        }
    }

    // 5. Settings & Keybinding
    // ===================================
    function loadSettings() {
        const savedSettings = localStorage.getItem('tetrisSettings_v3');
        if (savedSettings) {
            settings = { ...settings, ...JSON.parse(savedSettings) };
        }
    }

    function saveSettings() {
        settings.das = parseInt(dasSlider.value, 10);
        settings.arr = parseInt(arrSlider.value, 10);
        settings.showGhost = ghostToggle.checked;
        localStorage.setItem('tetrisSettings_v3', JSON.stringify(settings));
        showStartScreen();
    }

    function showSettingsScreen() {
        startScreen.classList.remove('visible');
        settingsScreen.classList.add('visible');

        dasSlider.value = settings.das;
        dasValue.textContent = settings.das;
        arrSlider.value = settings.arr;
        arrValue.textContent = settings.arr;
        ghostToggle.checked = settings.showGhost;
        updateKeybindingButtons();
    }

    function showAboutScreen() {
        startScreen.classList.remove('visible');
        document.getElementById('aboutScreen').classList.add('visible');
    }
    
    dasSlider.addEventListener('input', (e) => dasValue.textContent = e.target.value);
    arrSlider.addEventListener('input', (e) => arrValue.textContent = e.target.value);

    function updateKeybindingButtons() {
        document.querySelectorAll('.keybind-button').forEach(button => {
            const action = button.dataset.action;
            button.textContent = formatKeyName(settings.keybindings[action]);
        });
    }

    function startRebinding(action, button) {
        if (isRebinding) return;
        isRebinding = true;
        button.textContent = "æŒ‰ä¸‹ä¸€ä¸ªé”®";
        button.classList.add('is-binding');

        const keydownHandler = (e) => {
            e.preventDefault();
            const newKey = e.key.toLowerCase();
            
            for(const act in settings.keybindings){
                if(settings.keybindings[act] === newKey){
                    settings.keybindings[act] = null;
                }
            }

            settings.keybindings[action] = newKey;
            isRebinding = false;
            button.classList.remove('is-binding');
            updateKeybindingButtons();
            window.removeEventListener('keydown', keydownHandler, true);
        };
        
        window.addEventListener('keydown', keydownHandler, true);
    }

    document.querySelectorAll('.keybind-button').forEach(button => {
        button.addEventListener('click', () => {
            startRebinding(button.dataset.action, button);
        });
    });

    function formatKeyName(key) {
        if (!key) return 'N/A';
        const keyMap = {
            'arrowup': 'â†‘', 'arrowdown': 'â†“', 'arrowleft': 'â†', 'arrowright': 'â†’', ' ': 'ç©ºæ ¼'
        };
        return keyMap[key] || key.toUpperCase();
    }

    // 6. Controls Event Listeners
    // ===================================
    document.addEventListener('keydown', e => {
        const key = e.key.toLowerCase();
        
        if (key === settings.keybindings.pause) {
            if (gameState === 'PLAYING' || gameState === 'PAUSED') togglePause();
            return;
        }

        if (key === 'escape' && (gameState === 'PLAYING' || gameState === 'PAUSED')) {
            if (!quitConfirmTimer && !e.repeat) {
                quitConfirmOverlay.classList.add('visible');
                quitConfirmTimer = setTimeout(() => {
                    quitConfirmOverlay.classList.remove('visible');
                    showStartScreen();
                }, QUIT_HOLD_DURATION);
            }
            return;
        }

        if (isRebinding) return;
        
        if (keysPressed[key] && [settings.keybindings.moveLeft, settings.keybindings.softDrop, settings.keybindings.moveRight].includes(key)) return;
        keysPressed[key] = true;

        if (gameState !== 'PLAYING' || isAnimating) return;

        let actionTaken = true;
        
        if (!e.repeat) {
            if (key === settings.keybindings.hardDrop) {
                while (!checkCollision(piece, grid)) piece.y++;
                piece.y--;
                playSound('drop');
                lockPiece();
                clearLines();
                actionTaken = false;
            } else if (key === settings.keybindings.moveLeft) {
                const oldX = piece.x;
                piece.x--;
                if (checkCollision(piece, grid)) {
                    piece.x++;
                } else if (oldX !== piece.x) {
                    playSound('move');
                }
            } else if (key === settings.keybindings.moveRight) {
                const oldX = piece.x;
                piece.x++;
                if (checkCollision(piece, grid)) {
                    piece.x--;
                } else if (oldX !== piece.x) {
                    playSound('move');
                }
            } else if (key === settings.keybindings.softDrop) {
                const oldY = piece.y;
                piece.y++;
                if (checkCollision(piece, grid)) {
                    piece.y--;
                } else {
                    dropCounter = 0;
                    if (gameMode === 'CLASSIC') score += 1;
                    if (oldY !== piece.y) {
                        playSound('move');
                    }
                }
            } else if (key === settings.keybindings.rotate180) {
                rotate(piece, 2);
            } else if (key === settings.keybindings.rotateCW) {
                rotate(piece, 1);
            } else if (key === settings.keybindings.rotateCCW) {
                rotate(piece, -1);
            } else if (key === settings.keybindings.hold) {
                handleHold();
            } else {
                actionTaken = false;
            }
        } else {
            actionTaken = false;
        }

        if (actionTaken) {
             draw();
        }
    });
    
    document.addEventListener('keyup', e => {
        const key = e.key.toLowerCase();
        
        if (key === 'escape') {
            clearTimeout(quitConfirmTimer);
            quitConfirmTimer = null;
            quitConfirmOverlay.classList.remove('visible');
        }

        keysPressed[key] = false;
        if (key === settings.keybindings.moveLeft) {
            moveState.left.timer = 0;
            moveState.left.arrTimer = 0;
        } else if (key === settings.keybindings.moveRight) {
            moveState.right.timer = 0;
            moveState.right.arrTimer = 0;
        } else if (key === settings.keybindings.softDrop) {
            moveState.down.timer = 0;
            moveState.down.arrTimer = 0;
        }
    });

    // æ·»åŠ ç”¨æˆ·äº¤äº’äº‹ä»¶æ¥å¯åŠ¨éŸ³é¢‘
    document.addEventListener('click', function initAudioOnFirstClick() {
        if (!audioContext) {
            initAudioSystem();
        }
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
        // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨ï¼Œåªéœ€è¦æ‰§è¡Œä¸€æ¬¡
        document.removeEventListener('click', initAudioOnFirstClick);
    });
    
    // é”®ç›˜äº‹ä»¶ä¹Ÿå¯ä»¥å¯åŠ¨éŸ³é¢‘
    document.addEventListener('keydown', function initAudioOnFirstKey() {
        if (!audioContext) {
            initAudioSystem();
        }
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
        // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨ï¼Œåªéœ€è¦æ‰§è¡Œä¸€æ¬¡
        document.removeEventListener('keydown', initAudioOnFirstKey);
    });

    // Initial Load
    loadSettings();
    loadHighScore();
    updateUI();
    
    // é¢„åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿï¼ˆä½†ä¸ä¼šçœŸæ­£å¯åŠ¨ï¼Œç›´åˆ°ç”¨æˆ·äº¤äº’ï¼‰
    initAudioSystem();
    </script>
</body>
</html>
